// Code generated by MockGen. DO NOT EDIT.
// Source: go.uber.org/mock/mockgen/internal/tests/package_mode (interfaces: Food,Eater,Animal,Human,Primate,Car,Driver,UrbanResident,Farmer,Earth)
//
// Generated by this command:
//
//	mockgen -typed -package=mock -destination=mock/interfaces.go . Food,Eater,Animal,Human,Primate,Car,Driver,UrbanResident,Farmer,Earth
//

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
	package_mode "go.uber.org/mock/mockgen/internal/tests/package_mode"
	cars "go.uber.org/mock/mockgen/internal/tests/package_mode/cars"
	fuel "go.uber.org/mock/mockgen/internal/tests/package_mode/fuel"
)

// MockFood is a mock of Food interface.
type MockFood struct {
	ctrl     *gomock.Controller
	recorder *MockFoodMockRecorder
	isgomock struct{}
}

// MockFoodMockRecorder is the mock recorder for MockFood.
type MockFoodMockRecorder struct {
	mock *MockFood
}

// NewMockFood creates a new mock instance.
func NewMockFood(ctrl *gomock.Controller) *MockFood {
	mock := &MockFood{ctrl: ctrl}
	mock.recorder = &MockFoodMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFood) EXPECT() *MockFoodMockRecorder {
	return m.recorder
}

// Calories mocks base method.
func (m *MockFood) Calories() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Calories")
	ret0, _ := ret[0].(int)
	return ret0
}

// Calories indicates an expected call of Calories.
func (mr *MockFoodMockRecorder) Calories() *MockFoodCaloriesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Calories", reflect.TypeOf((*MockFood)(nil).Calories))
	return &MockFoodCaloriesCall{Call: call}
}

// MockFoodCaloriesCall wrap *gomock.Call
type MockFoodCaloriesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFoodCaloriesCall) Return(arg0 int) *MockFoodCaloriesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFoodCaloriesCall) Do(f func() int) *MockFoodCaloriesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFoodCaloriesCall) DoAndReturn(f func() int) *MockFoodCaloriesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockEater is a mock of Eater interface.
type MockEater struct {
	ctrl     *gomock.Controller
	recorder *MockEaterMockRecorder
	isgomock struct{}
}

// MockEaterMockRecorder is the mock recorder for MockEater.
type MockEaterMockRecorder struct {
	mock *MockEater
}

// NewMockEater creates a new mock instance.
func NewMockEater(ctrl *gomock.Controller) *MockEater {
	mock := &MockEater{ctrl: ctrl}
	mock.recorder = &MockEaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEater) EXPECT() *MockEaterMockRecorder {
	return m.recorder
}

// Eat mocks base method.
func (m *MockEater) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockEaterMockRecorder) Eat(foods ...any) *MockEaterEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockEater)(nil).Eat), foods...)
	return &MockEaterEatCall{Call: call}
}

// MockEaterEatCall wrap *gomock.Call
type MockEaterEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEaterEatCall) Return() *MockEaterEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEaterEatCall) Do(f func(...package_mode.Food)) *MockEaterEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEaterEatCall) DoAndReturn(f func(...package_mode.Food)) *MockEaterEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockAnimal is a mock of Animal interface.
type MockAnimal struct {
	ctrl     *gomock.Controller
	recorder *MockAnimalMockRecorder
	isgomock struct{}
}

// MockAnimalMockRecorder is the mock recorder for MockAnimal.
type MockAnimalMockRecorder struct {
	mock *MockAnimal
}

// NewMockAnimal creates a new mock instance.
func NewMockAnimal(ctrl *gomock.Controller) *MockAnimal {
	mock := &MockAnimal{ctrl: ctrl}
	mock.recorder = &MockAnimalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAnimal) EXPECT() *MockAnimalMockRecorder {
	return m.recorder
}

// Breathe mocks base method.
func (m *MockAnimal) Breathe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Breathe")
}

// Breathe indicates an expected call of Breathe.
func (mr *MockAnimalMockRecorder) Breathe() *MockAnimalBreatheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Breathe", reflect.TypeOf((*MockAnimal)(nil).Breathe))
	return &MockAnimalBreatheCall{Call: call}
}

// MockAnimalBreatheCall wrap *gomock.Call
type MockAnimalBreatheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAnimalBreatheCall) Return() *MockAnimalBreatheCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAnimalBreatheCall) Do(f func()) *MockAnimalBreatheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAnimalBreatheCall) DoAndReturn(f func()) *MockAnimalBreatheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eat mocks base method.
func (m *MockAnimal) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockAnimalMockRecorder) Eat(foods ...any) *MockAnimalEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockAnimal)(nil).Eat), foods...)
	return &MockAnimalEatCall{Call: call}
}

// MockAnimalEatCall wrap *gomock.Call
type MockAnimalEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAnimalEatCall) Return() *MockAnimalEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAnimalEatCall) Do(f func(...package_mode.Food)) *MockAnimalEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAnimalEatCall) DoAndReturn(f func(...package_mode.Food)) *MockAnimalEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sleep mocks base method.
func (m *MockAnimal) Sleep(duration time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sleep", duration)
}

// Sleep indicates an expected call of Sleep.
func (mr *MockAnimalMockRecorder) Sleep(duration any) *MockAnimalSleepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockAnimal)(nil).Sleep), duration)
	return &MockAnimalSleepCall{Call: call}
}

// MockAnimalSleepCall wrap *gomock.Call
type MockAnimalSleepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockAnimalSleepCall) Return() *MockAnimalSleepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockAnimalSleepCall) Do(f func(time.Duration)) *MockAnimalSleepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockAnimalSleepCall) DoAndReturn(f func(time.Duration)) *MockAnimalSleepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockHuman is a mock of Human interface.
type MockHuman struct {
	ctrl     *gomock.Controller
	recorder *MockHumanMockRecorder
	isgomock struct{}
}

// MockHumanMockRecorder is the mock recorder for MockHuman.
type MockHumanMockRecorder struct {
	mock *MockHuman
}

// NewMockHuman creates a new mock instance.
func NewMockHuman(ctrl *gomock.Controller) *MockHuman {
	mock := &MockHuman{ctrl: ctrl}
	mock.recorder = &MockHumanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHuman) EXPECT() *MockHumanMockRecorder {
	return m.recorder
}

// Breathe mocks base method.
func (m *MockHuman) Breathe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Breathe")
}

// Breathe indicates an expected call of Breathe.
func (mr *MockHumanMockRecorder) Breathe() *MockHumanBreatheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Breathe", reflect.TypeOf((*MockHuman)(nil).Breathe))
	return &MockHumanBreatheCall{Call: call}
}

// MockHumanBreatheCall wrap *gomock.Call
type MockHumanBreatheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHumanBreatheCall) Return() *MockHumanBreatheCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHumanBreatheCall) Do(f func()) *MockHumanBreatheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHumanBreatheCall) DoAndReturn(f func()) *MockHumanBreatheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eat mocks base method.
func (m *MockHuman) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockHumanMockRecorder) Eat(foods ...any) *MockHumanEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockHuman)(nil).Eat), foods...)
	return &MockHumanEatCall{Call: call}
}

// MockHumanEatCall wrap *gomock.Call
type MockHumanEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHumanEatCall) Return() *MockHumanEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHumanEatCall) Do(f func(...package_mode.Food)) *MockHumanEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHumanEatCall) DoAndReturn(f func(...package_mode.Food)) *MockHumanEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sleep mocks base method.
func (m *MockHuman) Sleep(duration time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sleep", duration)
}

// Sleep indicates an expected call of Sleep.
func (mr *MockHumanMockRecorder) Sleep(duration any) *MockHumanSleepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockHuman)(nil).Sleep), duration)
	return &MockHumanSleepCall{Call: call}
}

// MockHumanSleepCall wrap *gomock.Call
type MockHumanSleepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockHumanSleepCall) Return() *MockHumanSleepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockHumanSleepCall) Do(f func(time.Duration)) *MockHumanSleepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockHumanSleepCall) DoAndReturn(f func(time.Duration)) *MockHumanSleepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPrimate is a mock of Primate interface.
type MockPrimate struct {
	ctrl     *gomock.Controller
	recorder *MockPrimateMockRecorder
	isgomock struct{}
}

// MockPrimateMockRecorder is the mock recorder for MockPrimate.
type MockPrimateMockRecorder struct {
	mock *MockPrimate
}

// NewMockPrimate creates a new mock instance.
func NewMockPrimate(ctrl *gomock.Controller) *MockPrimate {
	mock := &MockPrimate{ctrl: ctrl}
	mock.recorder = &MockPrimateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPrimate) EXPECT() *MockPrimateMockRecorder {
	return m.recorder
}

// Breathe mocks base method.
func (m *MockPrimate) Breathe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Breathe")
}

// Breathe indicates an expected call of Breathe.
func (mr *MockPrimateMockRecorder) Breathe() *MockPrimateBreatheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Breathe", reflect.TypeOf((*MockPrimate)(nil).Breathe))
	return &MockPrimateBreatheCall{Call: call}
}

// MockPrimateBreatheCall wrap *gomock.Call
type MockPrimateBreatheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPrimateBreatheCall) Return() *MockPrimateBreatheCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPrimateBreatheCall) Do(f func()) *MockPrimateBreatheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPrimateBreatheCall) DoAndReturn(f func()) *MockPrimateBreatheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eat mocks base method.
func (m *MockPrimate) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockPrimateMockRecorder) Eat(foods ...any) *MockPrimateEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockPrimate)(nil).Eat), foods...)
	return &MockPrimateEatCall{Call: call}
}

// MockPrimateEatCall wrap *gomock.Call
type MockPrimateEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPrimateEatCall) Return() *MockPrimateEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPrimateEatCall) Do(f func(...package_mode.Food)) *MockPrimateEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPrimateEatCall) DoAndReturn(f func(...package_mode.Food)) *MockPrimateEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sleep mocks base method.
func (m *MockPrimate) Sleep(duration time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sleep", duration)
}

// Sleep indicates an expected call of Sleep.
func (mr *MockPrimateMockRecorder) Sleep(duration any) *MockPrimateSleepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockPrimate)(nil).Sleep), duration)
	return &MockPrimateSleepCall{Call: call}
}

// MockPrimateSleepCall wrap *gomock.Call
type MockPrimateSleepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPrimateSleepCall) Return() *MockPrimateSleepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPrimateSleepCall) Do(f func(time.Duration)) *MockPrimateSleepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPrimateSleepCall) DoAndReturn(f func(time.Duration)) *MockPrimateSleepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCar is a mock of Car interface.
type MockCar[FuelType fuel.Fuel] struct {
	ctrl     *gomock.Controller
	recorder *MockCarMockRecorder[FuelType]
	isgomock struct{}
}

// MockCarMockRecorder is the mock recorder for MockCar.
type MockCarMockRecorder[FuelType fuel.Fuel] struct {
	mock *MockCar[FuelType]
}

// NewMockCar creates a new mock instance.
func NewMockCar[FuelType fuel.Fuel](ctrl *gomock.Controller) *MockCar[FuelType] {
	mock := &MockCar[FuelType]{ctrl: ctrl}
	mock.recorder = &MockCarMockRecorder[FuelType]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCar[FuelType]) EXPECT() *MockCarMockRecorder[FuelType] {
	return m.recorder
}

// Brand mocks base method.
func (m *MockCar[FuelType]) Brand() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Brand")
	ret0, _ := ret[0].(string)
	return ret0
}

// Brand indicates an expected call of Brand.
func (mr *MockCarMockRecorder[FuelType]) Brand() *MockCarBrandCall[FuelType] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Brand", reflect.TypeOf((*MockCar[FuelType])(nil).Brand))
	return &MockCarBrandCall[FuelType]{Call: call}
}

// MockCarBrandCall wrap *gomock.Call
type MockCarBrandCall[FuelType fuel.Fuel] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCarBrandCall[FuelType]) Return(arg0 string) *MockCarBrandCall[FuelType] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCarBrandCall[FuelType]) Do(f func() string) *MockCarBrandCall[FuelType] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCarBrandCall[FuelType]) DoAndReturn(f func() string) *MockCarBrandCall[FuelType] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FuelTank mocks base method.
func (m *MockCar[FuelType]) FuelTank() cars.FuelTank[FuelType] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FuelTank")
	ret0, _ := ret[0].(cars.FuelTank[FuelType])
	return ret0
}

// FuelTank indicates an expected call of FuelTank.
func (mr *MockCarMockRecorder[FuelType]) FuelTank() *MockCarFuelTankCall[FuelType] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FuelTank", reflect.TypeOf((*MockCar[FuelType])(nil).FuelTank))
	return &MockCarFuelTankCall[FuelType]{Call: call}
}

// MockCarFuelTankCall wrap *gomock.Call
type MockCarFuelTankCall[FuelType fuel.Fuel] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCarFuelTankCall[FuelType]) Return(arg0 cars.FuelTank[FuelType]) *MockCarFuelTankCall[FuelType] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCarFuelTankCall[FuelType]) Do(f func() cars.FuelTank[FuelType]) *MockCarFuelTankCall[FuelType] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCarFuelTankCall[FuelType]) DoAndReturn(f func() cars.FuelTank[FuelType]) *MockCarFuelTankCall[FuelType] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Refuel mocks base method.
func (m *MockCar[FuelType]) Refuel(arg0 FuelType, volume int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Refuel", arg0, volume)
	ret0, _ := ret[0].(error)
	return ret0
}

// Refuel indicates an expected call of Refuel.
func (mr *MockCarMockRecorder[FuelType]) Refuel(arg0, volume any) *MockCarRefuelCall[FuelType] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Refuel", reflect.TypeOf((*MockCar[FuelType])(nil).Refuel), arg0, volume)
	return &MockCarRefuelCall[FuelType]{Call: call}
}

// MockCarRefuelCall wrap *gomock.Call
type MockCarRefuelCall[FuelType fuel.Fuel] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCarRefuelCall[FuelType]) Return(arg0 error) *MockCarRefuelCall[FuelType] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCarRefuelCall[FuelType]) Do(f func(FuelType, int) error) *MockCarRefuelCall[FuelType] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCarRefuelCall[FuelType]) DoAndReturn(f func(FuelType, int) error) *MockCarRefuelCall[FuelType] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockDriver is a mock of Driver interface.
type MockDriver[FuelType fuel.Fuel, CarType package_mode.Car[FuelType]] struct {
	ctrl     *gomock.Controller
	recorder *MockDriverMockRecorder[FuelType, CarType]
	isgomock struct{}
}

// MockDriverMockRecorder is the mock recorder for MockDriver.
type MockDriverMockRecorder[FuelType fuel.Fuel, CarType package_mode.Car[FuelType]] struct {
	mock *MockDriver[FuelType, CarType]
}

// NewMockDriver creates a new mock instance.
func NewMockDriver[FuelType fuel.Fuel, CarType package_mode.Car[FuelType]](ctrl *gomock.Controller) *MockDriver[FuelType, CarType] {
	mock := &MockDriver[FuelType, CarType]{ctrl: ctrl}
	mock.recorder = &MockDriverMockRecorder[FuelType, CarType]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDriver[FuelType, CarType]) EXPECT() *MockDriverMockRecorder[FuelType, CarType] {
	return m.recorder
}

// Drive mocks base method.
func (m *MockDriver[FuelType, CarType]) Drive(car CarType) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Drive", car)
}

// Drive indicates an expected call of Drive.
func (mr *MockDriverMockRecorder[FuelType, CarType]) Drive(car any) *MockDriverDriveCall[FuelType, CarType] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drive", reflect.TypeOf((*MockDriver[FuelType, CarType])(nil).Drive), car)
	return &MockDriverDriveCall[FuelType, CarType]{Call: call}
}

// MockDriverDriveCall wrap *gomock.Call
type MockDriverDriveCall[FuelType fuel.Fuel, CarType package_mode.Car[FuelType]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverDriveCall[FuelType, CarType]) Return() *MockDriverDriveCall[FuelType, CarType] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverDriveCall[FuelType, CarType]) Do(f func(CarType)) *MockDriverDriveCall[FuelType, CarType] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverDriveCall[FuelType, CarType]) DoAndReturn(f func(CarType)) *MockDriverDriveCall[FuelType, CarType] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Wroom mocks base method.
func (m *MockDriver[FuelType, CarType]) Wroom() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wroom")
	ret0, _ := ret[0].(error)
	return ret0
}

// Wroom indicates an expected call of Wroom.
func (mr *MockDriverMockRecorder[FuelType, CarType]) Wroom() *MockDriverWroomCall[FuelType, CarType] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wroom", reflect.TypeOf((*MockDriver[FuelType, CarType])(nil).Wroom))
	return &MockDriverWroomCall[FuelType, CarType]{Call: call}
}

// MockDriverWroomCall wrap *gomock.Call
type MockDriverWroomCall[FuelType fuel.Fuel, CarType package_mode.Car[FuelType]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockDriverWroomCall[FuelType, CarType]) Return(arg0 error) *MockDriverWroomCall[FuelType, CarType] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockDriverWroomCall[FuelType, CarType]) Do(f func() error) *MockDriverWroomCall[FuelType, CarType] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockDriverWroomCall[FuelType, CarType]) DoAndReturn(f func() error) *MockDriverWroomCall[FuelType, CarType] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUrbanResident is a mock of UrbanResident interface.
type MockUrbanResident struct {
	ctrl     *gomock.Controller
	recorder *MockUrbanResidentMockRecorder
	isgomock struct{}
}

// MockUrbanResidentMockRecorder is the mock recorder for MockUrbanResident.
type MockUrbanResidentMockRecorder struct {
	mock *MockUrbanResident
}

// NewMockUrbanResident creates a new mock instance.
func NewMockUrbanResident(ctrl *gomock.Controller) *MockUrbanResident {
	mock := &MockUrbanResident{ctrl: ctrl}
	mock.recorder = &MockUrbanResidentMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUrbanResident) EXPECT() *MockUrbanResidentMockRecorder {
	return m.recorder
}

// Breathe mocks base method.
func (m *MockUrbanResident) Breathe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Breathe")
}

// Breathe indicates an expected call of Breathe.
func (mr *MockUrbanResidentMockRecorder) Breathe() *MockUrbanResidentBreatheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Breathe", reflect.TypeOf((*MockUrbanResident)(nil).Breathe))
	return &MockUrbanResidentBreatheCall{Call: call}
}

// MockUrbanResidentBreatheCall wrap *gomock.Call
type MockUrbanResidentBreatheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentBreatheCall) Return() *MockUrbanResidentBreatheCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentBreatheCall) Do(f func()) *MockUrbanResidentBreatheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentBreatheCall) DoAndReturn(f func()) *MockUrbanResidentBreatheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Do mocks base method.
func (m *MockUrbanResident) Do(work *package_mode.Work) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", work)
	ret0, _ := ret[0].(error)
	return ret0
}

// Do indicates an expected call of Do.
func (mr *MockUrbanResidentMockRecorder) Do(work any) *MockUrbanResidentDoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockUrbanResident)(nil).Do), work)
	return &MockUrbanResidentDoCall{Call: call}
}

// MockUrbanResidentDoCall wrap *gomock.Call
type MockUrbanResidentDoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentDoCall) Return(arg0 error) *MockUrbanResidentDoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentDoCall) Do(f func(*package_mode.Work) error) *MockUrbanResidentDoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentDoCall) DoAndReturn(f func(*package_mode.Work) error) *MockUrbanResidentDoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Drive mocks base method.
func (m *MockUrbanResident) Drive(car cars.HyundaiSolaris) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Drive", car)
}

// Drive indicates an expected call of Drive.
func (mr *MockUrbanResidentMockRecorder) Drive(car any) *MockUrbanResidentDriveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drive", reflect.TypeOf((*MockUrbanResident)(nil).Drive), car)
	return &MockUrbanResidentDriveCall{Call: call}
}

// MockUrbanResidentDriveCall wrap *gomock.Call
type MockUrbanResidentDriveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentDriveCall) Return() *MockUrbanResidentDriveCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentDriveCall) Do(f func(cars.HyundaiSolaris)) *MockUrbanResidentDriveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentDriveCall) DoAndReturn(f func(cars.HyundaiSolaris)) *MockUrbanResidentDriveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eat mocks base method.
func (m *MockUrbanResident) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockUrbanResidentMockRecorder) Eat(foods ...any) *MockUrbanResidentEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockUrbanResident)(nil).Eat), foods...)
	return &MockUrbanResidentEatCall{Call: call}
}

// MockUrbanResidentEatCall wrap *gomock.Call
type MockUrbanResidentEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentEatCall) Return() *MockUrbanResidentEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentEatCall) Do(f func(...package_mode.Food)) *MockUrbanResidentEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentEatCall) DoAndReturn(f func(...package_mode.Food)) *MockUrbanResidentEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LivesInACity mocks base method.
func (m *MockUrbanResident) LivesInACity() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LivesInACity")
}

// LivesInACity indicates an expected call of LivesInACity.
func (mr *MockUrbanResidentMockRecorder) LivesInACity() *MockUrbanResidentLivesInACityCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LivesInACity", reflect.TypeOf((*MockUrbanResident)(nil).LivesInACity))
	return &MockUrbanResidentLivesInACityCall{Call: call}
}

// MockUrbanResidentLivesInACityCall wrap *gomock.Call
type MockUrbanResidentLivesInACityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentLivesInACityCall) Return() *MockUrbanResidentLivesInACityCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentLivesInACityCall) Do(f func()) *MockUrbanResidentLivesInACityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentLivesInACityCall) DoAndReturn(f func()) *MockUrbanResidentLivesInACityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sleep mocks base method.
func (m *MockUrbanResident) Sleep(duration time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sleep", duration)
}

// Sleep indicates an expected call of Sleep.
func (mr *MockUrbanResidentMockRecorder) Sleep(duration any) *MockUrbanResidentSleepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockUrbanResident)(nil).Sleep), duration)
	return &MockUrbanResidentSleepCall{Call: call}
}

// MockUrbanResidentSleepCall wrap *gomock.Call
type MockUrbanResidentSleepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentSleepCall) Return() *MockUrbanResidentSleepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentSleepCall) Do(f func(time.Duration)) *MockUrbanResidentSleepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentSleepCall) DoAndReturn(f func(time.Duration)) *MockUrbanResidentSleepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Wroom mocks base method.
func (m *MockUrbanResident) Wroom() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wroom")
	ret0, _ := ret[0].(error)
	return ret0
}

// Wroom indicates an expected call of Wroom.
func (mr *MockUrbanResidentMockRecorder) Wroom() *MockUrbanResidentWroomCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wroom", reflect.TypeOf((*MockUrbanResident)(nil).Wroom))
	return &MockUrbanResidentWroomCall{Call: call}
}

// MockUrbanResidentWroomCall wrap *gomock.Call
type MockUrbanResidentWroomCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUrbanResidentWroomCall) Return(arg0 error) *MockUrbanResidentWroomCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUrbanResidentWroomCall) Do(f func() error) *MockUrbanResidentWroomCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUrbanResidentWroomCall) DoAndReturn(f func() error) *MockUrbanResidentWroomCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockFarmer is a mock of Farmer interface.
type MockFarmer struct {
	ctrl     *gomock.Controller
	recorder *MockFarmerMockRecorder
	isgomock struct{}
}

// MockFarmerMockRecorder is the mock recorder for MockFarmer.
type MockFarmerMockRecorder struct {
	mock *MockFarmer
}

// NewMockFarmer creates a new mock instance.
func NewMockFarmer(ctrl *gomock.Controller) *MockFarmer {
	mock := &MockFarmer{ctrl: ctrl}
	mock.recorder = &MockFarmerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFarmer) EXPECT() *MockFarmerMockRecorder {
	return m.recorder
}

// Breathe mocks base method.
func (m *MockFarmer) Breathe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Breathe")
}

// Breathe indicates an expected call of Breathe.
func (mr *MockFarmerMockRecorder) Breathe() *MockFarmerBreatheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Breathe", reflect.TypeOf((*MockFarmer)(nil).Breathe))
	return &MockFarmerBreatheCall{Call: call}
}

// MockFarmerBreatheCall wrap *gomock.Call
type MockFarmerBreatheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerBreatheCall) Return() *MockFarmerBreatheCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerBreatheCall) Do(f func()) *MockFarmerBreatheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerBreatheCall) DoAndReturn(f func()) *MockFarmerBreatheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Do mocks base method.
func (m *MockFarmer) Do(work *package_mode.Work) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", work)
	ret0, _ := ret[0].(error)
	return ret0
}

// Do indicates an expected call of Do.
func (mr *MockFarmerMockRecorder) Do(work any) *MockFarmerDoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockFarmer)(nil).Do), work)
	return &MockFarmerDoCall{Call: call}
}

// MockFarmerDoCall wrap *gomock.Call
type MockFarmerDoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerDoCall) Return(arg0 error) *MockFarmerDoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerDoCall) Do(f func(*package_mode.Work) error) *MockFarmerDoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerDoCall) DoAndReturn(f func(*package_mode.Work) error) *MockFarmerDoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Drive mocks base method.
func (m *MockFarmer) Drive(car cars.FordF150) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Drive", car)
}

// Drive indicates an expected call of Drive.
func (mr *MockFarmerMockRecorder) Drive(car any) *MockFarmerDriveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drive", reflect.TypeOf((*MockFarmer)(nil).Drive), car)
	return &MockFarmerDriveCall{Call: call}
}

// MockFarmerDriveCall wrap *gomock.Call
type MockFarmerDriveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerDriveCall) Return() *MockFarmerDriveCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerDriveCall) Do(f func(cars.FordF150)) *MockFarmerDriveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerDriveCall) DoAndReturn(f func(cars.FordF150)) *MockFarmerDriveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eat mocks base method.
func (m *MockFarmer) Eat(foods ...package_mode.Food) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range foods {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Eat", varargs...)
}

// Eat indicates an expected call of Eat.
func (mr *MockFarmerMockRecorder) Eat(foods ...any) *MockFarmerEatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eat", reflect.TypeOf((*MockFarmer)(nil).Eat), foods...)
	return &MockFarmerEatCall{Call: call}
}

// MockFarmerEatCall wrap *gomock.Call
type MockFarmerEatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerEatCall) Return() *MockFarmerEatCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerEatCall) Do(f func(...package_mode.Food)) *MockFarmerEatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerEatCall) DoAndReturn(f func(...package_mode.Food)) *MockFarmerEatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LivesInAVillage mocks base method.
func (m *MockFarmer) LivesInAVillage() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LivesInAVillage")
}

// LivesInAVillage indicates an expected call of LivesInAVillage.
func (mr *MockFarmerMockRecorder) LivesInAVillage() *MockFarmerLivesInAVillageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LivesInAVillage", reflect.TypeOf((*MockFarmer)(nil).LivesInAVillage))
	return &MockFarmerLivesInAVillageCall{Call: call}
}

// MockFarmerLivesInAVillageCall wrap *gomock.Call
type MockFarmerLivesInAVillageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerLivesInAVillageCall) Return() *MockFarmerLivesInAVillageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerLivesInAVillageCall) Do(f func()) *MockFarmerLivesInAVillageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerLivesInAVillageCall) DoAndReturn(f func()) *MockFarmerLivesInAVillageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sleep mocks base method.
func (m *MockFarmer) Sleep(duration time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sleep", duration)
}

// Sleep indicates an expected call of Sleep.
func (mr *MockFarmerMockRecorder) Sleep(duration any) *MockFarmerSleepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sleep", reflect.TypeOf((*MockFarmer)(nil).Sleep), duration)
	return &MockFarmerSleepCall{Call: call}
}

// MockFarmerSleepCall wrap *gomock.Call
type MockFarmerSleepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerSleepCall) Return() *MockFarmerSleepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerSleepCall) Do(f func(time.Duration)) *MockFarmerSleepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerSleepCall) DoAndReturn(f func(time.Duration)) *MockFarmerSleepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Wroom mocks base method.
func (m *MockFarmer) Wroom() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wroom")
	ret0, _ := ret[0].(error)
	return ret0
}

// Wroom indicates an expected call of Wroom.
func (mr *MockFarmerMockRecorder) Wroom() *MockFarmerWroomCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wroom", reflect.TypeOf((*MockFarmer)(nil).Wroom))
	return &MockFarmerWroomCall{Call: call}
}

// MockFarmerWroomCall wrap *gomock.Call
type MockFarmerWroomCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockFarmerWroomCall) Return(arg0 error) *MockFarmerWroomCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockFarmerWroomCall) Do(f func() error) *MockFarmerWroomCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockFarmerWroomCall) DoAndReturn(f func() error) *MockFarmerWroomCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockEarth is a mock of Earth interface.
type MockEarth struct {
	ctrl     *gomock.Controller
	recorder *MockEarthMockRecorder
	isgomock struct{}
}

// MockEarthMockRecorder is the mock recorder for MockEarth.
type MockEarthMockRecorder struct {
	mock *MockEarth
}

// NewMockEarth creates a new mock instance.
func NewMockEarth(ctrl *gomock.Controller) *MockEarth {
	mock := &MockEarth{ctrl: ctrl}
	mock.recorder = &MockEarthMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEarth) EXPECT() *MockEarthMockRecorder {
	return m.recorder
}

// AddHumans mocks base method.
func (m *MockEarth) AddHumans(arg0 package_mode.HumansCount) []package_mode.Human {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddHumans", arg0)
	ret0, _ := ret[0].([]package_mode.Human)
	return ret0
}

// AddHumans indicates an expected call of AddHumans.
func (mr *MockEarthMockRecorder) AddHumans(arg0 any) *MockEarthAddHumansCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddHumans", reflect.TypeOf((*MockEarth)(nil).AddHumans), arg0)
	return &MockEarthAddHumansCall{Call: call}
}

// MockEarthAddHumansCall wrap *gomock.Call
type MockEarthAddHumansCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEarthAddHumansCall) Return(arg0 []package_mode.Human) *MockEarthAddHumansCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEarthAddHumansCall) Do(f func(package_mode.HumansCount) []package_mode.Human) *MockEarthAddHumansCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEarthAddHumansCall) DoAndReturn(f func(package_mode.HumansCount) []package_mode.Human) *MockEarthAddHumansCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HumanPopulation mocks base method.
func (m *MockEarth) HumanPopulation() package_mode.HumansCount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HumanPopulation")
	ret0, _ := ret[0].(package_mode.HumansCount)
	return ret0
}

// HumanPopulation indicates an expected call of HumanPopulation.
func (mr *MockEarthMockRecorder) HumanPopulation() *MockEarthHumanPopulationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HumanPopulation", reflect.TypeOf((*MockEarth)(nil).HumanPopulation))
	return &MockEarthHumanPopulationCall{Call: call}
}

// MockEarthHumanPopulationCall wrap *gomock.Call
type MockEarthHumanPopulationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEarthHumanPopulationCall) Return(arg0 package_mode.HumansCount) *MockEarthHumanPopulationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEarthHumanPopulationCall) Do(f func() package_mode.HumansCount) *MockEarthHumanPopulationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEarthHumanPopulationCall) DoAndReturn(f func() package_mode.HumansCount) *MockEarthHumanPopulationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
